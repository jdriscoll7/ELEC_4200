KCPSM6 Assembler log file for program '\\sage.eng.auburn.edu\homes\desktop\class\4200_lab\final\assembly\final_project.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 28 Nov 2018
Assembly timestamp: 19:38:30

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 40B hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 188
Memory locations available: 3908


Assembly listing

 Addr Code                       Instruction

 000                             ; Format for seven-segment display definitions.
 000                             ;
 000                             ; [X] [X] [X] [X] [digit_3] [digit_2] [digit_1] [digit_0]
 000                             ;
 000                             ;
 000                             ; Enable interrupts for the program to work.
 000                             ;
 000  28001                      ENABLE INTERRUPT
 001                             ;
 001                             ;
 001                       main: 
 001  2002F                      CALL 02F[super_display]
 002  20004                      CALL 004[display_values]
 003  22001                      JUMP 001[main]
 004                             ;
 004                             ;
 004                             ;
 004                             ;
 004                             ;
 004                             ; Function display_values
 004                             ;
 004                             ;     - Outputs each of the four stored hex values on LED's.
 004                             ;     - Register usage:
 004                             ;         - s0: stores which of stored values to display (0-3)
 004                             ;         - s1: stores which port to write the digit to
 004                             ;         - s2: stores the value stored in memory (changed by SPI)
 004                             ;         - s3 and s4: index the segment decode table
 004                             ;         - s5 and s6: Counter values to implement delay (this function needs to run for 4 seconds before return).
 004                             ;         - sF: holds seven segment display value
 004                             ;
 004                             ;
 004                             ;
 004             display_values: 
 004  01000                      LOAD s0, 00                                      ; Begin with first stored value.
 005  01101                      LOAD s1, 01                                      ; Write first value to first display.
 006  0154F                      LOAD s5, 4F
 007  0161F                      LOAD s6, 1F
 008                outer_delay: 
 008  19501                      SUB s5, 01
 009  0161F                      LOAD s6, 1F
 00A                inner_delay: 
 00A  19601                      SUB s6, 01
 00B               display_loop: 
 00B  0A200                      FETCH s2, (s0)                                   ; Get value stored in memory.
 00C  01300                      LOAD s3, 00[segment_decode'upper]                ; Upper bound of table.
 00D  0141E                      LOAD s4, 1E[segment_decode'lower]                ; Lower bound of table.
 00E  10420                      ADD s4, s2                                       ; Index the table.
 00F  13300                      ADDCY s3, 00                                     ; Add carry from right half.
 010  24340                      CALL@ (s3, s4)                                   ; Return hex decode value in sF.
 011  2CF10                      OUTPUT sF, (s1)                                  ; Writes seven segment pattern to display.
 012  200A6                      CALL 0A6[short_delay]                            ; Short delay.
 013                             ;
 013                             ; Keep repeating until all 4 stored values are displayed.
 013  11001                      ADD s0, 01                                       ; Set s0 to next stored value (index).
 014  14106                      SL0 s1                                           ; Update which display to write to.
 015  1D004                      COMPARE s0, 04                                   ; If s0 is 4, then done.
 016  3600B                      JUMP NZ, 00B[display_loop]                       ; Loop if not done.
 017  01000                      LOAD s0, 00                                      ; Reset s0.
 018  01101                      LOAD s1, 01                                      ; Reset s1.
 019                             ;
 019                             ; Need to keep running function for 4 seconds - decide which delay loop to jump to.
 019  1D600                      COMPARE s6, 00
 01A  3600A                      JUMP NZ, 00A[inner_delay]
 01B  1D500                      COMPARE s5, 00
 01C  36008                      JUMP NZ, 008[outer_delay]
 01D  25000                      RETURN 
 01E                             ;
 01E                             ;
 01E                             ;
 01E                             ;
 01E                             ;
 01E                             ; Function segment_decode
 01E                             ;
 01E                             ;    - Holds a table of seven-segment display values.
 01E                             ;
 01E                             ;    - Access elements in table with CALL@ (decode_table'upper, decode_table'lower + index).
 01E                             ;
 01E                             ;    - Returns value in register sF.
 01E                             ;
 01E                             TABLE segment_character_decode#, [40,79,24,30,19,12,02,78,00,10,08,03,46,21,06,0E,38]
 01E             segment_decode: 
 01E                             ;
 01E  21F40                      LOAD&RETURN sF, 40[segment_character_decode#:40]
 01F  21F79                      LOAD&RETURN sF, 79[segment_character_decode#:79]
 020  21F24                      LOAD&RETURN sF, 24[segment_character_decode#:24]
 021  21F30                      LOAD&RETURN sF, 30[segment_character_decode#:30]
 022  21F19                      LOAD&RETURN sF, 19[segment_character_decode#:19]
 023  21F12                      LOAD&RETURN sF, 12[segment_character_decode#:12]
 024  21F02                      LOAD&RETURN sF, 02[segment_character_decode#:02]
 025  21F78                      LOAD&RETURN sF, 78[segment_character_decode#:78]
 026  21F00                      LOAD&RETURN sF, 00[segment_character_decode#:00]
 027  21F10                      LOAD&RETURN sF, 10[segment_character_decode#:10]
 028  21F08                      LOAD&RETURN sF, 08[segment_character_decode#:08]
 029  21F03                      LOAD&RETURN sF, 03[segment_character_decode#:03]
 02A  21F46                      LOAD&RETURN sF, 46[segment_character_decode#:46]
 02B  21F21                      LOAD&RETURN sF, 21[segment_character_decode#:21]
 02C  21F06                      LOAD&RETURN sF, 06[segment_character_decode#:06]
 02D  21F0E                      LOAD&RETURN sF, 0E[segment_character_decode#:0E]
 02E  21F38                      LOAD&RETURN sF, 38[segment_character_decode#:38]
 02F                             ;
 02F                             ;
 02F                             ;
 02F                             ;
 02F                             ;
 02F                             ; Function super_display
 02F                             ;
 02F                             ;     - Displays ELEC 4200 on segment displays.
 02F                             ;
 02F                             ;     - s0, s1, and s2 are used for manual delay
 02F                             ;     - s3 is used to determine which pattern to display (substring of "ELEC 4200");
 02F                             ;       this will be done basically with a case statement.
 02F                             ;
 02F              super_display: 
 02F                             ; Use s0, s1, and s2 as counters for manual delays.
 02F  01004                      LOAD s0, 04
 030  01104                      LOAD s1, 04
 031  0120D                      LOAD s2, 0D
 032  01300                      LOAD s3, 00
 033         super_display_loop: 
 033  0120D                      LOAD s2, 0D
 034           outer_delay_loop: 
 034  19201                      SUB s2, 01
 035  01104                      LOAD s1, 04
 036  01004                      LOAD s0, 04
 037          middle_delay_loop: 
 037  19101                      SUB s1, 01
 038  01004                      LOAD s0, 04
 039           inner_delay_loop: 
 039  19001                      SUB s0, 01
 03A                             ;
 03A                             ; Do the case statement here.
 03A                             ;
 03A  1D300                      COMPARE s3, 00
 03B  3204C                      JUMP Z, 04C[seq0]
 03C  1D301                      COMPARE s3, 01
 03D  32055                      JUMP Z, 055[seq1]
 03E  1D302                      COMPARE s3, 02
 03F  3205E                      JUMP Z, 05E[seq2]
 040  1D303                      COMPARE s3, 03
 041  32067                      JUMP Z, 067[seq3]
 042  1D304                      COMPARE s3, 04
 043  32070                      JUMP Z, 070[seq4]
 044  1D305                      COMPARE s3, 05
 045  32079                      JUMP Z, 079[seq5]
 046  1D306                      COMPARE s3, 06
 047  32082                      JUMP Z, 082[seq6]
 048  1D307                      COMPARE s3, 07
 049  3208B                      JUMP Z, 08B[seq7]
 04A  1D308                      COMPARE s3, 08
 04B  32094                      JUMP Z, 094[seq8]
 04C                       seq0: 
 04C                             ; Print "E"
 04C  2B061                      OUTPUTK 06, 1
 04D  200A6                      CALL 0A6[short_delay]
 04E  2BFF2                      OUTPUTK FF, 2
 04F  200A6                      CALL 0A6[short_delay]
 050  2BFF4                      OUTPUTK FF, 4
 051  200A6                      CALL 0A6[short_delay]
 052  2BFF8                      OUTPUTK FF, 8
 053  200A6                      CALL 0A6[short_delay]
 054  2209C                      JUMP 09C[next_loop]
 055                       seq1: 
 055                             ; Print "EL"
 055  2B471                      OUTPUTK 47, 1
 056  200A6                      CALL 0A6[short_delay]
 057  2B062                      OUTPUTK 06, 2
 058  200A6                      CALL 0A6[short_delay]
 059  2BFF4                      OUTPUTK FF, 4
 05A  200A6                      CALL 0A6[short_delay]
 05B  2BFF8                      OUTPUTK FF, 8
 05C  200A6                      CALL 0A6[short_delay]
 05D  2209C                      JUMP 09C[next_loop]
 05E                       seq2: 
 05E                             ; Print "ELE"
 05E  2B061                      OUTPUTK 06, 1
 05F  200A6                      CALL 0A6[short_delay]
 060  2B472                      OUTPUTK 47, 2
 061  200A6                      CALL 0A6[short_delay]
 062  2B064                      OUTPUTK 06, 4
 063  200A6                      CALL 0A6[short_delay]
 064  2BFF8                      OUTPUTK FF, 8
 065  200A6                      CALL 0A6[short_delay]
 066  2209C                      JUMP 09C[next_loop]
 067                       seq3: 
 067                             ; Print "ELEC"
 067  2B461                      OUTPUTK 46, 1
 068  200A6                      CALL 0A6[short_delay]
 069  2B062                      OUTPUTK 06, 2
 06A  200A6                      CALL 0A6[short_delay]
 06B  2B474                      OUTPUTK 47, 4
 06C  200A6                      CALL 0A6[short_delay]
 06D  2B068                      OUTPUTK 06, 8
 06E  200A6                      CALL 0A6[short_delay]
 06F  2209C                      JUMP 09C[next_loop]
 070                       seq4: 
 070                             ; Print "LEC "
 070  2BFF1                      OUTPUTK FF, 1
 071  200A6                      CALL 0A6[short_delay]
 072  2B462                      OUTPUTK 46, 2
 073  200A6                      CALL 0A6[short_delay]
 074  2B064                      OUTPUTK 06, 4
 075  200A6                      CALL 0A6[short_delay]
 076  2B478                      OUTPUTK 47, 8
 077  200A6                      CALL 0A6[short_delay]
 078  2209C                      JUMP 09C[next_loop]
 079                       seq5: 
 079                             ; Print "EC 4"
 079  2B191                      OUTPUTK 19, 1
 07A  200A6                      CALL 0A6[short_delay]
 07B  2BFF2                      OUTPUTK FF, 2
 07C  200A6                      CALL 0A6[short_delay]
 07D  2B464                      OUTPUTK 46, 4
 07E  200A6                      CALL 0A6[short_delay]
 07F  2B068                      OUTPUTK 06, 8
 080  200A6                      CALL 0A6[short_delay]
 081  2209C                      JUMP 09C[next_loop]
 082                       seq6: 
 082                             ; Print "C 42"
 082  2B241                      OUTPUTK 24, 1
 083  200A6                      CALL 0A6[short_delay]
 084  2B192                      OUTPUTK 19, 2
 085  200A6                      CALL 0A6[short_delay]
 086  2BFF4                      OUTPUTK FF, 4
 087  200A6                      CALL 0A6[short_delay]
 088  2B468                      OUTPUTK 46, 8
 089  200A6                      CALL 0A6[short_delay]
 08A  2209C                      JUMP 09C[next_loop]
 08B                       seq7: 
 08B                             ; Print " 420"
 08B  2B401                      OUTPUTK 40, 1
 08C  200A6                      CALL 0A6[short_delay]
 08D  2B242                      OUTPUTK 24, 2
 08E  200A6                      CALL 0A6[short_delay]
 08F  2B194                      OUTPUTK 19, 4
 090  200A6                      CALL 0A6[short_delay]
 091  2BFF8                      OUTPUTK FF, 8
 092  200A6                      CALL 0A6[short_delay]
 093  2209C                      JUMP 09C[next_loop]
 094                       seq8: 
 094                             ; Print "4200"
 094  2B401                      OUTPUTK 40, 1
 095  200A6                      CALL 0A6[short_delay]
 096  2B402                      OUTPUTK 40, 2
 097  200A6                      CALL 0A6[short_delay]
 098  2B244                      OUTPUTK 24, 4
 099  200A6                      CALL 0A6[short_delay]
 09A  2B198                      OUTPUTK 19, 8
 09B  200A6                      CALL 0A6[short_delay]
 09C                  next_loop: 
 09C                             ; Make delay decision.
 09C                             ;
 09C                             ; Inner delay loop
 09C  1D000                      COMPARE s0, 00
 09D  36039                      JUMP NZ, 039[inner_delay_loop]
 09E                             ;
 09E                             ; Middle delay loop
 09E  1D100                      COMPARE s1, 00
 09F  36037                      JUMP NZ, 037[middle_delay_loop]
 0A0                             ;
 0A0                             ; Outer delay loop
 0A0  1D200                      COMPARE s2, 00
 0A1  36034                      JUMP NZ, 034[outer_delay_loop]
 0A2                             ;
 0A2                             ; Check if all substrings of "ELEC 4200" have been displayed.
 0A2  11301                      ADD s3, 01
 0A3  1D309                      COMPARE s3, 09
 0A4  36033                      JUMP NZ, 033[super_display_loop]
 0A5                             ;
 0A5  25000                      RETURN 
 0A6                             ;
 0A6                             ;
 0A6                             ;
 0A6                             ;
 0A6                             ;
 0A6                             ; Function short_delay
 0A6                             ;     - a few tenths of a second software delay
 0A6                             ;
 0A6                short_delay: 
 0A6  01E4F                      LOAD sE, 4F
 0A7               f_outer_loop: 
 0A7  01D4F                      LOAD sD, 4F
 0A8               f_inner_loop: 
 0A8  19D01                      SUB sD, 01
 0A9  1DD00                      COMPARE sD, 00
 0AA  360A8                      JUMP NZ, 0A8[f_inner_loop]
 0AB  1DE00                      COMPARE sE, 00
 0AC  19E01                      SUB sE, 01
 0AD  360A7                      JUMP NZ, 0A7[f_outer_loop]
 0AE  25000                      RETURN 
 0AF                             ;
 0AF                             ;
 0AF                             ;
 0AF                             ;
 0AF                             ;
 0AF                             ; Interrupt service routine.
 0AF                             ;
 0AF                             ;     - Used to signal to the processor that
 0AF                             ;       an SPI data transfer has taken place and
 0AF                             ;       that data should be captured.
 0AF                             ;
 0AF                             ;     - Uses s0 and s1 for all operations.
 0AF                             ;         - s0: Used for data input.
 0AF                             ;         - s1: Holds masked address data.
 0AF                             ;         - s2: Holds masked value data.
 0AF                             ;
 0AF                             ;
 3FF                             ADDRESS 3FF                                      ; Address of interrupt vector (in specifications).
 3FF  37001                      REGBANK B                                        ; Use different register bank for interrupt.
 400                             ;
 400                             ;
 400                             ; Constants needed for ISR (input port number and data masks).
 400                             CONSTANT input_port, 00
 400                             CONSTANT digit_address_mask, 30
 400                             CONSTANT digit_value_mask, 0F
 400                             ;
 400                             ;
 400                             ;
 400                        isr: 
 400                             ; Setup registers s1 and s2 and load input data into s0.
 400  09000                      INPUT s0, 00[input_port]                         ; Place input data into s0.
 401  01130                      LOAD s1, 30[digit_address_mask]                  ; Load register s1 with address mask.
 402  0120F                      LOAD s2, 0F[digit_value_mask]                    ; Load register s2 with value mask.
 403                             ;
 403                             ; Actually perform the masking.
 403  02100                      AND s1, s0                                       ; Extract address bits of input.
 404  02200                      AND s2, s0                                       ; Extract value bits of input.
 405                             ;
 405                             ; Shift address bits of input so they are in least significant bits of register.
 405  1410E                      SR0 s1
 406  1410E                      SR0 s1
 407  1410E                      SR0 s1
 408  1410E                      SR0 s1
 409                             ;
 409                             ; Update stored value determined by address bits.
 409  2E210                      STORE s2, (s1)
 40A  37000                      REGBANK A                                        ; Change register bank back to user bank.
 40B  29001                      RETURNI ENABLE                                   ; Return from interrupt.


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

\\sage.eng.auburn.edu\homes\desktop\class\4200_lab\final\assembly\final_project.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    19'd         
 timestamp_minutes  38'd         
 timestamp_seconds  30'd         
 datestamp_year     18'd         
 datestamp_month    11'd         
 datestamp_day      28'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 input_port         00           final_project.psm
 digit_address_mask 30           final_project.psm
 digit_value_mask   0F           final_project.psm



List of defined tables

 TABLE name                  Table                                                 Source PSM File

 segment_character_decode#   [40,79,24,30,19,12,02,78,00,10,08,03,46,21,06,0E,38]  final_project.psm



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "28 Nov 2018"  
 timestamp$        "19:38:30"     



List of line labels

   Label                Addr  Source PSM File

   main                 001   final_project.psm
   display_values       004   final_project.psm
   outer_delay          008   final_project.psm
   inner_delay          00A   final_project.psm
   display_loop         00B   final_project.psm
   segment_decode       01E   final_project.psm
   super_display        02F   final_project.psm
   super_display_loop   033   final_project.psm
   outer_delay_loop     034   final_project.psm
   middle_delay_loop    037   final_project.psm
   inner_delay_loop     039   final_project.psm
   seq0                 04C   final_project.psm
   seq1                 055   final_project.psm
   seq2                 05E   final_project.psm
   seq3                 067   final_project.psm
   seq4                 070   final_project.psm
   seq5                 079   final_project.psm
   seq6                 082   final_project.psm
   seq7                 08B   final_project.psm
   seq8                 094   final_project.psm
   next_loop            09C   final_project.psm
   short_delay          0A6   final_project.psm
   f_outer_loop         0A7   final_project.psm
   f_inner_loop         0A8   final_project.psm
 * isr                  400   final_project.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             21
 STAR              -

 AND               2
 OR                -
 XOR               -

 ADD               3
 ADDCY             1
 SUB               7
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          18
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               4
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           2

 INPUT             1
 OUTPUT            1
 OUTPUTK          36

 STORE             1
 FETCH             1

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             27
 JUMP@             -
 CALL             39
 CALL@             1
 RETURN            3
 LOAD&RETURN      17

 HWBUILD           -



End of KCPSM6 log file.
